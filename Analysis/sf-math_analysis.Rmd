---
title: "SF-Math analysis"
author: "Rose Schneider"
date: "5/13/2018"
output: html_document
---

```{r setup, include=FALSE}
rm(list = ls())
require("knitr")
opts_knit$set(root.dir = "~/Documents/Projects/sf_math/") #this is specific to RMS, change accordingly
library(tidyverse)
library(magrittr)
library(langcog)
library(lme4)
```

#Setup

##Loading data
Each task is stored as a separate CSV. Need to tidy and check each sheet individually.
```{r}
#First load Give N
given.raw <- read.csv("Data/GiveN.csv")

#Then load Highest Count
highestcount.raw <- read.csv("Data/HighestCount.csv")

#Then load SF
sf.raw <- read.csv("Data/SF.csv")

#Then load Next Number
nextnumber.raw <- read.csv("Data/NextNumber.csv")

#Then load Math Facts
mathfacts.raw <- read.csv("Data/MathFacts.csv")

#Then load Indefinite
indefinite.raw <- read.csv("Data/Indefinite.csv")

#combine for looping
tasks <- list(given.raw, highestcount.raw, sf.raw, 
              nextnumber.raw, mathfacts.raw, indefinite.raw)
```

##Tidy data
Remove all exclusions. Make sure that anyone who is excluded by Give N is not included in other analyses.
```{r}
#make a df of total exclusions across all tasks
check_exclusions <- function(df){
    exclusions <- df %>%
      filter(exclude == 1)%>%
      distinct(SID, age, sex, experimenter, location, exclude, exclude_reason)
    
    exclusions$task = deparse(substitute(df))
    if (length(exclusions$SID) > 0) {
    return(exclusions)
    } else {
      return("No exclusions")
    }
}

#check each task
given.exclusions <- check_exclusions(given.raw)
highestcount.exclusions <- check_exclusions(highestcount.raw)
sf.exclusions <- check_exclusions(sf.raw)
nextnumber.exclusions <- check_exclusions(nextnumber.raw)
mathfacts.exclusions <- check_exclusions(mathfacts.raw)
indefinite.exclusions <- check_exclusions(indefinite.raw) #deal with this later

#bind these together
all_exclusions <- bind_rows(given.exclusions, highestcount.exclusions, 
                            sf.exclusions, nextnumber.exclusions, 
                            mathfacts.exclusions)

#review these guys manually
#NB RMS - you need to check on exclusion criteria

##once you have reviewed these guys manually, run the below code
exclusion_SIDs <- as.vector(all_exclusions$SID)

'%!in%' <- function(x,y)!('%in%'(x,y))

exclude <- function(df){
  df %<>%
    filter(SID %!in% exclusion_SIDs)
}

given.df <- exclude(given.raw)
highestcount.df <- exclude(highestcount.raw)
nextnumber.df <- exclude(nextnumber.raw)
sf.df <- exclude(sf.raw)
mathfacts.df <- exclude(mathfacts.raw)
```

##Sanity checks
###Do we have the same number (and same participants) for each task?
```{r}
#get unique IDs
get_unique_SID <- function(df){
  unique <- df %>%
    distinct(SID, age)
  
  unique$task = deparse(substitute(df))
  return(unique)
}

unique.given <- get_unique_SID(given.df)
unique.highestcount <- get_unique_SID(highestcount.df)
unique.sf <- get_unique_SID(sf.df)
unique.nextnumber <- get_unique_SID(nextnumber.df)
unique.mathfacts <- get_unique_SID(mathfacts.df)

#bind all unique IDs and ages together
all_unique <- bind_rows(unique.given, unique.highestcount, unique.sf, 
          unique.nextnumber, unique.mathfacts)%>%
  mutate(SID = factor(SID))

#dumb way to do this, but there need to be 5 tasks per participant
#find all participants that do not have 5 tasks
unique.check <- all_unique %>%
  group_by(SID, age)%>%
  summarise(n = n())%>%
  filter(n != 5)

##NB - you must manally review these. 
##To-do for RMS: You should automate whether these are included or excluded
```

##Coding check
Is everything marked as correct actually correct?
```{r}
sf.df %<>%
  mutate(correct_check = ifelse(num_answer == (starting_num + 1), 1, 0))%>%
  mutate(correct = correct_check)

#because nextnumber and mathfacts have IDK as answers, convert these to numbers
##NB RMS: Do NOT forget to exclude these numbers from analyses

nextnumber.df %<>%
  mutate(num_answer = ifelse(num_answer == "IDK", -1000,
                             as.numeric(as.character(num_answer))))%>%
  mutate(num_answer = ifelse(is.na(num_answer), -2000, 
                             as.numeric(as.character(num_answer))))%>%
  mutate(num_answer = as.numeric(as.character(num_answer)))%>%
  mutate(correct_check = ifelse(num_answer == (num_queried + 1), 1, 0), 
         correct = correct_check)

#math facts
#need to to some cleanup for num_answer, because it's a little cray
# answers <- as.vector(c("2", '6', '22', '65', '58', '87', '33', '94', '21'))
# tmp <- mathfacts.df %>%
#   mutate(num_answer = as.character(num_answer))%>%
#   mutate(num_answer_check = ifelse(num_answer == "IDK" | is.na(num_answer), 
#                                    as.character(-1000), num_answer))
```

#Productivity
```{r}
#NB, productivity is manually coded for now, will need to be done programmatically in the future

#performance by productivity
#extract productivity classifications, assign
productive_SIDS <- highestcount.df %>%
  filter(productive == "productive")%>%
  distinct(SID)

productive_SIDS <- as.vector(productive_SIDS$SID)

productivity_classification <- function(df) {
  tmp <- df %>%
    mutate(productive = ifelse(SID %in% productive_SIDS, "productive", "nonproductive"))
  return(tmp)
}

#do across tasks
sf.df <- productivity_classification(sf.df)
nextnumber.df <- productivity_classification(nextnumber.df)
mathfacts.df <- productivity_classification(mathfacts.df)
```

#Highest count
```{r}
#relation between initial and final
initial_final <- highestcount.df %>%
  distinct(SID, age, initial_highest, final_highest, productive)%>%
  mutate(initial_highest = as.numeric(initial_highest), 
         initial_final = as.numeric(final_highest))

ggplot(initial_final, aes(x = initial_highest, y = final_highest, color = productive)) +
  geom_point()

#distribution of initial
ggplot(initial_final, aes(x = initial_highest, fill = productive)) + 
  geom_histogram(position = position_dodge()) +
  scale_x_continuous(name="Initial highest count", breaks=seq(0,130,10))

ggplot(initial_final, aes(x = final_highest, fill = productive)) + 
  geom_histogram(position = position_dodge()) + 
  scale_x_continuous(name = "Final highest count", breaks=seq(0,130,10))
```

#SF
```{r}
#is there a significant accuracy difference between first and second half of experiment? 
sf.df %<>%
  mutate(half = ifelse(trial < 10, "first", "second"))

sf.half.check <- sf.df %>%
  group_by(half)%>%
  multi_boot_standard("correct", na.rm = TRUE)%>%
  filter(!is.na(SID))

#significant difference between first and second half?
t.test(subset(sf.df, half == "first")$correct, subset(sf.df, half == "second")$correct, 
       var.equal = TRUE)

#use mem to account for subject-level variability
m1 <- glmer(correct ~ half + (1 | SID), data=sf.df, 
            family=binomial, control=glmerControl(optimizer="bobyqa",
                            optCtrl=list(maxfun=2e5)))
m0 <- glmer(correct ~  1  + (1 | SID), data=sf.df, 
            family=binomial, control=glmerControl(optimizer="bobyqa",
                            optCtrl=list(maxfun=2e5)))
anova(m0,m1)

```